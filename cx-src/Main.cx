package;

import haxe.Int32;
import haxe.io.BytesOutput;
import haxe.io.BytesInput;
import haxe.io.Bytes;

import neko.Sys;
import neko.Lib;
import neko.io.File;
import neko.io.Path;

import flib.abc.Types;
import flib.swf.Types;

import flib.util.BitFields;
	
using StringTools;

typedef SIZE = {size:Int,str:String};

class Main {
	static function main() {		
		var args = Sys.args();
		if(args.length<1) {
			Lib.println("For help use --help option");
			Sys.exit(1);
		}
	
		var report = false;

		if(args[0]=="--help") {
			Lib.println("Usage: flib lib.swf/swc");
			Lib.println("\t@ var x(flibget_x,flibset_x), has 'x' removed, and flibget_x flibset_x turned to native getter/setters. flibget_x flibset_x must be inlined to avoid haxe code being destroyed");
			Lib.println("\t @ @:ns(\"flibdel\") inline function x() {} get's removed from the swc entirely, make sure this method is also inlined and is not used dynamicaly through down-casting/reflection or else it will break haxe code");
			Lib.println("\n");
			Lib.println("Alternatively: flib --report lib.swf/swc to report method sizes throughout");
			Sys.exit(0);
		}
		
		var src = args[0];
		if(src=="--report") {
			report = true;
			if(args.length<2) {
				Lib.println("ERROR --report needs argument");
				Sys.exit(0);
			}
			src = args[1];
		}
		
		//------------------------------------------------------------------------------------------
		//grab internal swf if using a .swc

		var swc = StringTools.endsWith(src,".swc");
		var swcsrc = src;
		if(swc) {
			#if windows
				if(Sys.command("7z",["-y","e",src,"library.swf"])!=0) {
					Lib.println("ERROR please make sure 7z has been added to PATH variables");
					Sys.exit(1);
				}
			#elseif unix
				Sys.command("unzip",[src,"library.swf"]);
			#else
				Lib.println("please specify compiler flag windows or unix on compilation of flib");
				Sys.exit(1);
			#end

			src = "library.swf";
		}
		
		//------------------------------------------------------------------------------------------
		//process loaded swf
		var inp = File.read(src,true);
		var reader = new flib.swf.Reader(inp);
		var swf = reader.readSwf();
		inp.close();
		
		if(report) {
			if(swc) {
				#if windows
					Sys.command("del",["library.swf"]);
				#else
					Sys.command("rm",["library.swf"]);
				#end
			}

			//------------------------------------------------------------------------------------------
			//process ABC blocks for size report.

			var ret:Array<SIZE> = [];
			for(tag in swf.tags) {
				switch(tag) {
					default:
					case tDoABC(abcdata):
						doreport(abcdata,ret);
					case tDefABC(_,_,abcdata):
						doreport(abcdata,ret);
				}
			}

			var total = 0;
			ret.sort(function (a,b) return b.size-a.size);
			for(i in ret) {
				Lib.println(i.str);
				total += i.size;
			}

			Lib.println("-------");
			Lib.println("total: "+duh(total));

		}else {

			//------------------------------------------------------------------------------------------
			//process ABC blocks for replacements and deletions.
			var ntags = [];
			for(tag in swf.tags) {
				ntags.push(switch(tag) {
					default:
						tag;
					case tDoABC(abcdata):
						tDoABC(doABC(abcdata));
					case tDefABC(lazy,name,abcdata):
						tDefABC(lazy,name,doABC(abcdata));
				});
			}
			swf.tags = ntags;
		
			//------------------------------------------------------------------------------------------
			//create new swf
			#if windows
				Sys.command("del",[src]);
			#else
				Sys.command("rm",[src]);
			#end
			var out = File.write(src,true);
			var writer = new flib.swf.Writer(out);
			writer.writeSwf(swf);
			out.flush();
			out.close();

			//------------------------------------------------------------------------------------------
			//inject new swf
	
			if(swc) {
				#if windows
					Sys.command("7z",["-y","a","-tzip",swcsrc,"library.swf"]);
					Sys.command("del",["library.swf"]);
				#else
				    Sys.command("zip",[swcsrc,"-d","library.swf"]);
					Sys.command("zip",[swcsrc,"library.swf"]);
					Sys.command("rm",["library.swf"]);
				#end
			}
		}
	}
	
	//----------------------------------------------------------------------------------------------

	private static inline function duh(bytes:Int) {
		$(mixin fix100(x) (Std.int((x)*100)/100));

		if     (bytes<1024) return bytes+"B";
		else if(bytes<1024*1024) return fix100(bytes/1024)+"KiB";
		else return fix100(bytes/1024/1024)+"MiB";
	}

	private static function doreport(abcdata:Bytes, ret:Array<SIZE>) {
		var reader = new flib.abc.Reader(new BytesInput(abcdata));
		var abc = reader.readABC();
				
		$(mixin string(n) abc.cpool.strings[n-1]);
		$(mixin multiname(n) ({
			var n2 = abc.cpool.names[n-1];
			switch(n2) {
//				case mQName(_,_,name): string(name);
				case mQName(_,ns,name):
					var pck = abc.cpool.nspaces[ns-1];
					var pckstr = string(pck.name);
					var nstr = string(name);
					if(pckstr.length!=0) pckstr+"."+nstr;
					else nstr;
				case mRTQName(_,name): string(name);
				case mMultiname(_,name,_): string(name);
				default: "";
			}
		}));

		var names = new Array<String>();
		for(i in abc.instances) {
			var clsname = multiname(i.name);
			for(t in i.traits) {
				switch(t.data) {
					case tdMethod(type,_,mid):
						var name = multiname(t.name);
						if(Type.enumEq(type,mtMethod))
							names[mid] = clsname+"::"+name;
					 	else if(Type.enumEq(type,mtGetter))
							names[mid] = clsname+"::set "+name;
						else
							names[mid] = clsname+"::get "+name;
					default:
				}
			}
			names[i.iinit] = clsname+"::new";
		}

		var ind = 0;
		for(i in abc.classes) {
			var clsname = multiname(abc.instances[ind].name);
			ind++;
			for(t in i.traits) {
				switch(t.data) {
					case tdMethod(type,_,mid):
						var name = multiname(t.name);
						if(Type.enumEq(type,mtMethod))
							names[mid] = clsname+"."+name;
					 	else if(Type.enumEq(type,mtGetter))
							names[mid] = clsname+".set "+name;
						else
							names[mid] = clsname+".get "+name;
					default:
				}
			}
			names[i.cinit] = clsname+".__init__";
		}

		for(m in abc.mbodies) {
			if(names[m.method]!=null) {
				var str = ""+duh(m.avm.length);
				while(str.length<10) str += " ";
				str += names[m.method];
				ret.push({size:m.avm.length,str:str});
			}
		}
	}

	//----------------------------------------------------------------------------------------------
	
	private static function doABC(abcdata:Bytes) {
		var reader = new flib.abc.Reader(new BytesInput(abcdata));
		var abc = reader.readABC();
		
		$(mixin string(n) abc.cpool.strings[n-1]);
		$(mixin multiname(n) ({
			var n2 = abc.cpool.names[n-1];
			switch(n2) {
				case mQName(_,_,name): string(name);
				case mRTQName(_,name): string(name);
				case mMultiname(_,name,_): string(name);
				default: "";
			}
		}));
		$(mixin flibdel(n) ({
			var n2 = abc.cpool.names[n-1];
			switch(n2) {
				case mQName(_,ns,name):
					var n3 = abc.cpool.nspaces[ns-1];
					string(n3.name);
				default: "";
			}
		}));
		
		var methodid = new Array<Int>();
		var id = 0;
		for(i in abc.methods) methodid.push(id++);
		
		$(mixin getsets(instances)
			for(i in instances) {
				var properties = new Hash<{x:Trait,y:Trait}>();
				var flibrem = new Hash<Void>();
				
				for(t in i.traits) {
					switch(t.data) {
						case tdMethod(type,x,y):
							if(Type.enumEq(type,mtMethod)) {
								var flibd = flibdel(t.name);
								var name = multiname(t.name);
								
								if(flibd=="flibdel")
									flibrem.set(name,null);
								if(flibd=="" && name.substr(0,8)=="flibdel_" && name.length>8) {
									flibrem.set(name,null);
									flibrem.set(name.substr(8),null);
								}
								
								if(name.length > 8 && name.startsWith("flibset_")) {
									var varn = name.substr(8);
									if(properties.exists(varn))
										properties.get(varn).y = t;
									else
										properties.set(varn,{x:null,y:t});
										
									t.data = tdMethod(mtSetter,x,y);
								}
								if(name.length > 8 && name.startsWith("flibget_")) {
									var varn = name.substr(8);
									if(properties.exists(varn))
										properties.get(varn).x = t;
									else
										properties.set(varn,{x:t,y:null});						
										
									t.data = tdMethod(mtGetter,x,y);
								}
							}
						case tdSlot(const,sid,_,_,_):
							var flibd = flibdel(t.name);
							var name = multiname(t.name);
							
							if(flibd=="flibdel")
								flibrem.set(name,null);
							if(flibd=="" && name.substr(0,8)=="flibdel_" && name.length>8) {
								//trace(name);
								flibrem.set(name,null);
								flibrem.set(name.substr(8),null);
							}
						default:
					}
				}
				
				var ntraits = [];
				for(t in i.traits) {
					switch(t.data) {
						case tdMethod(type,_,id):
							if(Type.enumEq(type,mtMethod)) {
								var name = multiname(t.name);
								if(!flibrem.exists(name))
									ntraits.push(t);
								else {
									methodid.remove(id);
								}
							}else
								ntraits.push(t);
						case tdSlot(const,_,_,_,_):
							var name = multiname(t.name);
							if(flibrem.exists(name))
								continue;
							if(!const) {	
								if(properties.exists(name)) {
									var p = properties.get(name);
									
									if(p.x!=null) p.x.name = t.name;
									if(p.y!=null) p.y.name = t.name;
									
									continue;
								}
							}
							ntraits.push(t);
						default:
							ntraits.push(t);
					}
				}
				
				i.traits = ntraits;
			}
		);
		
		getsets(abc.instances)
		getsets(abc.classes)
		
		//maps old method index, to new method index
		var methodset = new IntHash<Int>();
		var ind = 0;
		for(i in methodid) methodset.set(i,ind++);
		/*
		ind = 0;
		var i = 0;
		while(true) {
			if(i>=abc.methods.length) break;
			var method = abc.methods[i];
			if(methodset.exists(ind)) {
				i++;
				ind++;
				continue;
			}

			abc.methods.splice(i,1);
			ind++;
			continue;
		}
*/		
		var i = 0;
		while(true) {
			if(i>=abc.mbodies.length) break;
			var mbody = abc.mbodies[i];
			if(methodset.exists(mbody.method)) {
				i++;
				continue;
			}
			
			abc.mbodies.splice(i,1);
			continue;
		}
/*		
		for(i in abc.instances) {
			i.iinit = methodset.get(i.iinit);
			adtraits(i.traits);
		}
		for(i in abc.classes) {
			i.cinit = methodset.get(i.cinit);
			adtraits(i.traits);
		}
		for(i in abc.scripts) {
			i.init = methodset.get(i.init);
			adtraits(i.traits);
		}
		for(i in abc.mbodies) {
			i.method = methodset.get(i.method);
			adtraits(i.traits);
		}
		
		$(mixin adtraits(traits) {
			for(i in traits) {
				i.data = switch(i.data) {
					case tdFunction(sid,mid):
						tdFunction(sid,methodset.get(mid));
					case tdMethod(type,sid,mid):
						tdMethod(type,sid,methodset.get(mid));
					default: i.data;
				}
			}
		});
		*/
		var out = new BytesOutput();
		var writer = new flib.abc.Writer(out);
		writer.writeABC(abc);
		return out.getBytes();
	}
}
